# Singularis (Hackathon) — Regex/Heuristics Pipeline v3

## 1) Зачем это всё

**Цель:** извлекать из PDF **детерминированный граф знаний** с 8 типами узлов (`Input Fact, Hypothesis, Experiment, Technique, Result, Dataset, Analysis, Conclusion`) и типизированными рёбрами, достигая 80–90% качества LLM-рид-аута при 10–100× меньших времени и стоимости.
**Почему не LLM-only:** дорого, медленно, нестабильно на десятках миллионов статей; нужен «жёсткий» экстрактор, который **самообучается** от реальных сбоев.

---

## 2) Что уже сделано (ключевые улучшения)

**S0 (парсинг):**

* Нормализация переносов/дефисов; склейка одиночных `\n`→пробел.
* Подписи к фигурам/таблицам, римские `TABLE I`.
* Санитизация `doc_id` (arXiv/id файла, защита от «Title — Microsoft Word»).

**S1 (regex/heuristics):**

* Робастный экспандер предложений (не ломает `60.0%`, пары в скобках).
* Чистая нормализация чисел/процентов.
* Постпроцесс кандидатов: `merge_fragment_nodes`, `drop_nested_overlaps`, `suppress_overlaps`.
* Разводка `Dataset` vs `Result` (случай *measurements* закрыт).
* **Тематика (новое):**

  * **Router (top-k)**: ранжирование тем по `themes/*/triggers.yaml`, загрузка `common + выбранные темы` (k=1–2).
  * **Shared-lexicon:** общий `abbr/synonyms/hedging`, подмешивается всегда.
  * **Весовой микс:** итоговый `rule.weight *= theme_score`.
* Линковка по близости (оконные эвристики + figure↔text), базовые fallback-связи.

**S1.5 (AutoRule, офлайн):**

* Сбор `gaps`; LLM генерирует **мягкие** regex-кандидаты в нашем DSL → линтер → suggested-packs (ручной ревью).

  > LLM **не в проде**, только как генератор предложений.

**S2 (нормализация/граф):**

* Нормализация типов и дедуп по `(type, text)` с аккумулированием provenance.
* Валидация и ремап рёбер к допустимым парам; fallback-скелет для связности.
* Фиксированные позиции (preset): 8 колонок с `data.col/row → position`.

**Фронт (Cytoscape):**

* `preset`-рендер 8 колонок; **колоночные заголовки** как сервис-ноды.
* Подсветка рёбер по клику, двойной клик — карточка узла.
* Цветные типы рёбер, легенда внутри канваса, «волнистые» линии.
* Ручной выбор темы (override) — **готово** на стороне API/данных; UI-переключатель показан в ближайших шагах.

---

## 3) Архитектура (S0 → Router → S1 → S2 → S3)

1. **S0 — Parsing & Structuring (PDF→JSON):** секции (IMRaD+), капшены, нормализация, метаданные, `s0.json`.
2. **Theme Router (новое):**

   * Витрина текста: Abstract + Introduction + captions.
   * Скоринг тем по `themes/<topic>/triggers.yaml` (must/should/negative, веса); **top-k** тем + **shared-lexicon**.
   * Ручной override `?theme=<t1,t2>` сохраняется в отладке.
3. **S1 — Regex/Rules Extraction:** загрузка объединённого набора правил (common + темы), взвешивание правил по `theme_score`, отбор нод/рёбер, постпроцесс, `s1_graph.json`/`s1_debug.json`.
4. **S2 — Semantic Linking & Normalization:** нормализация/валидация/дедуп/позиционирование, `graph.json`/`s2_debug.json`.
5. **S3 — Cross-Paper Linking:** (после хакатона) лёгкие эмбеддинги на узлах и FAISS-индекс.

---

## 4) Форматы артефактов

Без изменений (см. v2). В `graph.json` у каждой ноды: канонический `type`, `data.col/row`, `position.{x,y}` для `preset`.

---

## 5) Правила и словари

* **`rules/common.yaml`** — универсальные правила (generic Theory/Experiment/Stats/Results).
* **`themes/`** — тематические пакеты:

  * `themes/<topic>/triggers.yaml` — триггеры (must/should/negative, веса, локальный порог/`topk`).
  * `themes/<topic>/lexicon.yaml` — аббревиатуры/синонимы/hedging для темы.
  * `themes/<topic>/rules.yaml` — тематические элементы (`elements:`) в том же DSL, что `common`.
* **`themes/shared-lexicon.yaml`** — общий слой (`abbr/synonyms/hedging_extra`), всегда активен.
* **Весовой микс:** при сборке активного набора `rule.weight = rule.weight * theme_score`.

---

## 6) «Самообучение» (S1.5 AutoRule)

* Триггерится при низком покрытии/Q-оценке: собираем `gaps`, прогоняем жёстким промптом к LLM → кандидаты-паттерны → линтер/санити → `rules_learned/*.yaml` (suggested) → ручной ревью/мердж.

---

## 7) Отладка: кейсы и фиксы

* **Парные проценты в *measurements*** — теперь один `Result`, без распила и без ложного `Dataset`.
* **Перекрытия pair vs single** — выигрывает более специфичное правило.
* **Рёбра на усечённых наборах** — сохраняется связность (fallback).
* **Тематический шум** — снижен: активны лишь `common + top-k темы`.

---

## 8) API/Фронт

**API:**

* `POST /parse` → S0 (doc_id)
* `POST /extract?doc_id=&theme=<t1,t2>` → S0→Router→S1→S2
* `GET /status/{doc_id}` → стадии/тайминги/артефакты
* `GET /preview/{doc_id}/{artifact}` → предпросмотры
* `GET /graph/{doc_id}` → граф

**Фронт:**

* Левая панель: загрузка, прогресс, предпросмотры, **(в планах) dropdown темы**.
* Правая: канвас (8 колонок, `preset`), легенда рёбер, подсветка связей.

---

## 9) Метрики качества (Q-оценка)

Композитный скор `Q ∈ [0,1]` для статей/пакетов:

* **SC (0.35)** — структурная полнота (наличие ключевых типов).
* **AC (0.25)** — покрытие смыслов Abstract/Conclusion (ROUGE-L/Jaccard по содержательным токенам).
* **QF (0.15)** — плотность количественных фактов (%, n, p, CI, OR/HR/β).
* **GC (0.15)** — связанность графа (Edges/Nodes, Giant Component).
* **PC (0.10)** — согласованность полярности (нет противоречий supports/refutes).

Светофор: **Green ≥ 0.75**, **Yellow 0.60–0.75**, **Red < 0.60** (в Red включается AutoRule).

---

## 10) Ближайшие шаги

1. Расширить универсальные `Result/Hypothesis`-пакеты (eigen/stability/PCA/accuracy/baselines).
2. Аббревиатуры в S2: `Long form (SHORT)` → унификация узлов.
3. Усилить линковку: окно «2 предложения/1 абзац» + figure↔text.
4. Автопайплайн S1.5: writeback `rules_learned/*.yaml` + sanity-гейты.
5. Срез 20–50 статей: кривые «качество→затраты», 10–50× экономия.
6. **Фронт: ручной выбор темы** (dropdown) и показ `theme_scores`.
7. **(ещё не сделано)** Быстрые **smoke-тесты** правил/триггеров и базовые регрессии (включим после интеграции фронтового выбора темы).

---

## 11) Как пользоваться

* «Есть S0–S2; хотим под PDF X» → кидай `s0.json`/`s1_debug.json`/фрагменты — вернём патчи `common.yaml`/`themes/*/rules.yaml` и, при необходимости, точечные фиксы в `s1.py`/`s2.py`.
* S3 (межстатейные связи) подключим после стабилизации Q-метрик.

---

**Итог:** Пайплайн стал **тематино-осознанным** (top-k router + shared-lexicon), **детерминированным** и **расширяемым** (AutoRule офлайн), с фиксированным 8-колоночным рендером и понятными метриками качества. Из «ближайших» пунктов не реализованы только быстрые smoke-тесты — вынесены на следующий спринт.
